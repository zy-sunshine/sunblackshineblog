# -*- coding: utf-8 -*-import os,loggingfrom google.appengine.api import users#from google.appengine.ext import dbfrom gae_adapter import db#from google.appengine.ext.db import Model as DBModelfrom gae_adapter import Model as DBModel#from google.appengine.api import memcachefrom django.core.cache import cache as memcachefrom google.appengine.api import mailfrom google.appengine.api import urlfetchfrom google.appengine.api import datastorefrom datetime import datetimeimport urllib, hashlib,urlparseimport zipfile,re,pickle,uuidimport configsfrom django.utils.translation import gettext_lazy as _logging.info('module base reloaded')class BaseModel(DBModel):    def __init__(self, parent=None, key_name=None, _app=None, **kwds):        self.__isdirty = False        DBModel.__init__(self, parent=None, key_name=None, _app=None, **kwds)        self.blog = configs.get_g_blog()    def __setattr__(self,attrname,value):        """        DataStore api stores all prop values say "email" is stored in "_email" so        we intercept the set attribute, see if it has changed, then check for an        onchanged method for that property to call        """        if (attrname.find('_') != 0):            if hasattr(self,'_' + attrname):                curval = getattr(self,'_' + attrname)                if curval != value:                    self.__isdirty = True                    if hasattr(self,attrname + '_onchange'):                        getattr(self,attrname + '_onchange')(curval,value)        DBModel.__setattr__(self,attrname,value)class Cache(DBModel):    cachekey = db.StringProperty(multiline=False)    content = db.TextProperty()#class Category(DBModel):class Category(BaseModel):    uid=db.IntegerProperty()    name=db.StringProperty(multiline=False)    slug=db.StringProperty(multiline=False)    parent_cat=db.SelfReferenceProperty()    @property    def posts(self):        return Entry.all().filter('entrytype =','post').filter("published =", True).filter('categorie_keys =',self)    @property    def count(self):        return self.posts.count()    def put(self):        DBModel.put(self)        self.blog.tigger_action("save_category",self)    def delete(self):        for entry in Entry.all().filter('categorie_keys =',self):            entry.categorie_keys.remove(self.key())            entry.put()        for cat in Category.all().filter('parent_cat =',self):            cat.delete()        DBModel.delete(self)        self.blog.tigger_action("delete_category",self)    def ID(self):        try:            id=self.key().id()            if id:                return id        except:            pass        if self.uid :            return self.uid        else:            #旧版本Category没有ID,为了与wordpress兼容            from random import randint            uid=randint(0,99999999)            cate=Category.all().filter('uid =',uid).get()            while cate:                uid=randint(0,99999999)                cate=Category.all().filter('uid =',uid).get()            self.uid=uid            print uid            self.put()            return uid    @classmethod    def get_from_id(cls,id):        cate=Category.get_by_id(id)        if cate:            return cate        else:            cate=Category.all().filter('uid =',id).get()            return cate    @property    def children(self):        key=self.key()        return [c for c in Category.all().filter('parent_cat =',self)]    @classmethod    def allTops(self):        return [c for c in Category.all() if not c.parent_cat]class Archive(DBModel):    monthyear = db.StringProperty(multiline=False)    year = db.StringProperty(multiline=False)    month = db.StringProperty(multiline=False)    entrycount = db.IntegerProperty(default=0)    date = db.DateTimeProperty(auto_now_add=True)class Tag(DBModel):    tag = db.StringProperty(multiline=False)    tagcount = db.IntegerProperty(default=0)    @property    def posts(self):        return Entry.all('entrytype =','post').filter("published =", True).filter('tags =',self)    @classmethod    def add(cls,value):        if value:            tag= Tag.get_by_key_name(value)            if not tag:                tag=Tag(key_name=value)                tag.tag=value            tag.tagcount+=1            tag.put()            return tag        else:            return None    @classmethod    def remove(cls,value):        if value:            tag= Tag.get_by_key_name(value)            if tag:                if tag.tagcount>1:                    tag.tagcount-=1                    tag.put()                else:                    tag.delete()class Link(BaseModel):#(DBModel):    href = db.StringProperty(multiline=False,default='')    linktype = db.StringProperty(multiline=False,default='blogroll')    linktext = db.StringProperty(multiline=False,default='')    linkcomment = db.StringProperty(multiline=False,default='')    createdate=db.DateTimeProperty(auto_now=True)    @property    def get_icon_url(self):        "get ico url of the wetsite"        ico_path = '/favicon.ico'        ix = self.href.find('/',len('http://') )        return (ix>0 and self.href[:ix] or self.href ) + ico_path    def put(self):        DBModel.put(self)        self.blog.tigger_action("save_link",self)    def delete(self):        DBModel.delete(self)        self.blog.tigger_action("delete_link",self)class Entry(BaseModel):    author = db.UserProperty()    author_name = db.StringProperty()    published = db.BooleanProperty(default=False)    content = db.TextProperty(default='')    readtimes = db.IntegerProperty(default=0)    title = db.StringProperty(multiline=False,default='')    date = db.DateTimeProperty(auto_now_add=True)    mod_date = db.DateTimeProperty(auto_now_add=True)    tags = db.StringListProperty()    categorie_keys=db.ListProperty(db.Key)    slug = db.StringProperty(multiline=False,default='')    link= db.StringProperty(multiline=False,default='')    monthyear = db.StringProperty(multiline=False)    entrytype = db.StringProperty(multiline=False,default='post',choices=[        'post','page'])    entry_parent=db.IntegerProperty(default=0)#When level=0 show on main menu.    menu_order=db.IntegerProperty(default=0)    commentcount = db.IntegerProperty(default=0)    trackbackcount = db.IntegerProperty(default=0)    allow_comment = db.BooleanProperty(default=True) #allow comment    #allow_pingback=db.BooleanProperty(default=False)    allow_trackback=db.BooleanProperty(default=True)    password=db.StringProperty()    #compatible with wordpress    is_wp=db.BooleanProperty(default=False)    post_id= db.IntegerProperty()    excerpt=db.StringProperty(multiline=True)    #external page    is_external_page=db.BooleanProperty(default=False)    target=db.StringProperty(default="_self")    external_page_address=db.StringProperty()    #keep in top    sticky=db.BooleanProperty(default=False)    postname=''    _relatepost=None    @property    def content_excerpt(self):        return self.get_content_excerpt(_('..more').decode('utf8'))    def get_author_user(self):        if not self.author:            self.author=self.blog.owner        return User.all().filter('email =',self.author.email()).get()    def get_content_excerpt(self,more='..more'):        if self.blog.show_excerpt:            if self.excerpt:                return self.excerpt+' <a href="/blog/%s">%s</a>'%(self.link,more)            else:                sc=self.content.split('<!--more-->')                if len(sc)>1:                    return sc[0]+u' <a href="/blog/%s">%s</a>'%(self.link,more)                else:                    from base import get_excerpt                    return get_excerpt(sc[0]) + u' <a href="/blog/%s">%s</a>'%(self.link,more)        else:            return self.content    def slug_onchange(self,curval,newval):        if not (curval==newval):            self.setpostname(newval)    def setpostname(self,newval):             #check and fix double slug            if newval:                slugcount=Entry.all()\                          .filter('entrytype',self.entrytype)\                          .filter('date <',self.date)\                          .filter('slug =',newval)\                          .filter('published',True)\                          .count()                if slugcount>0:                    self.postname=newval+str(slugcount)                else:                    self.postname=newval            else:                self.postname=""    @property    def fullurl(self):        return self.blog.baseurl+'/'+self.link;    @property    def categories(self):        try:            return db.GET(self.categorie_keys)        except:            return []    @property    def post_status(self):        return  self.published and 'publish' or 'draft'    def settags(self,values):        if not values:tags=[]        if type(values)==type([]):            tags=values        else:            tags=values.split(',')        if not self.tags:            removelist=[]            addlist=tags        else:            #search different  tags            removelist=[n for n in self.tags if n not in tags]            addlist=[n for n in tags if n not in self.tags]        for v in removelist:            Tag.remove(v)        for v in addlist:            Tag.add(v)        self.tags=tags    def get_comments_by_page(self,index,psize):        return self.comments().fetch(psize,offset = (index-1) * psize)    @property    def strtags(self):        return ','.join(self.tags)    @property    def edit_url(self):        return '/admin/%s?key=%s&action=edit'%(self.entrytype,self.key())    def comments(self):        if self.blog.comments_order:            return Comment.all().filter('entry =',self).order('-date')        else:            return Comment.all().filter('entry =',self).order('date')    def purecomments(self):        if self.blog.comments_order:            return Comment.all().filter('entry =',self).filter('ctype =',0).order('-date')        else:            return Comment.all().filter('entry =',self).filter('ctype =',0).order('date')    def trackcomments(self):        if self.blog.comments_order:            return Comment.all().filter('entry =',self).filter('ctype IN',[1,2]).order('-date')        else:            return Comment.all().filter('entry =',self).filter('ctype IN',[1,2]).order('date')    def commentsTops(self):        return [c for c  in self.purecomments() if c.parent_key()==None]    def delete_comments(self):        cmts = Comment.all().filter('entry =',self)        for comment in cmts:            comment.delete()        self.commentcount = 0        self.trackbackcount = 0    def update_commentno(self):        cmts = Comment.all().filter('entry =',self).order('date')        i=1        for comment in cmts:            if comment.no != i:                comment.no = i                comment.store()            i+=1    def update_archive(self,cnt=1):        """Checks to see if there is a month-year entry for the        month of current blog, if not creates it and increments count"""        my = self.date.strftime('%B %Y') # September-2008        sy = self.date.strftime('%Y') #2008        sm = self.date.strftime('%m') #09        archive = Archive.all().filter('monthyear',my).get()        if self.entrytype == 'post':            if not archive:                archive = Archive(monthyear=my,year=sy,month=sm,entrycount=1)                self.monthyear = my                archive.put()            else:                # ratchet up the count                archive.entrycount += cnt                archive.put()        self.blog.entrycount+=cnt        #self.blog.put()    def save(self,is_publish=False):        """        Use this instead of self.put(), as we do some other work here        @is_pub:Check if need publish id        """        #self.blog.tigger_action("pre_save_post",self,is_publish)        my = self.date.strftime('%B %Y') # September 2008        self.monthyear = my        old_publish=self.published        self.mod_date=datetime.now()        if is_publish:            if not self.is_wp:                self.put()                self.post_id=self.key().id()            #fix for old version            if not self.postname:                self.setpostname(self.slug)            vals={'year':self.date.year,'month':str(self.date.month).zfill(2),'day':self.date.day,                'postname':self.postname,'post_id':self.post_id}            if self.entrytype=='page':                if self.slug:                    self.link=self.postname                else:                    #use external page address as link                    if self.is_external_page:                       self.link=self.external_page_address                    else:                       self.link=self.blog.default_link_format%vals            else:                if self.blog.link_format and self.postname:                    self.link=self.blog.link_format.strip()%vals                else:                    self.link=self.blog.default_link_format%vals        self.published=is_publish        self.put()        if is_publish:            if self.blog.sitemap_ping:                Sitemap.NotifySearch()        if old_publish and not is_publish:            self.update_archive(-1)        if not old_publish and is_publish:            self.update_archive(1)        self.removecache()        self.put()        self.blog.tigger_action("save_post",self,is_publish)    def removecache(self):        memcache.delete('/')        memcache.delete('/'+self.link)        memcache.delete('/sitemap')        memcache.delete('blog.postcount')        self.blog.tigger_action("clean_post_cache",self)    @property    def next(self):        return Entry.all().filter('entrytype =','post').filter("published =", True).order('date').filter('date >',self.date).fetch(1)    @property    def prev(self):        return Entry.all().filter('entrytype =','post').filter("published =", True).order('-date').filter('date <',self.date).fetch(1)    @property    def relateposts(self):        if  self._relatepost:            return self._relatepost        else:            if self.tags:                try: self._relatepost= Entry.gql("WHERE published=True and tags IN :1 and post_id!=:2 order by post_id desc ",self.tags,self.post_id).fetch(5)                except: self._relatepost= []            else:                self._relatepost= []            return self._relatepost    @property    def trackbackurl(self):        if self.link.find("?")>-1:            return self.blog.baseurl+"/"+self.link+"&code="+str(self.key())        else:            return self.blog.baseurl+"/"+self.link+"?code="+str(self.key())    def getbylink(self):        pass    def delete(self):        self.blog.tigger_action("pre_delete_post",self)        if self.published:            self.update_archive(-1)        self.delete_comments()        DBModel.delete(self)        self.blog.tigger_action("delete_post",self)class User(DBModel):    user = db.UserProperty(required = False)    dispname = db.StringProperty()    email=db.StringProperty()    website = db.LinkProperty()    isadmin=db.BooleanProperty(default=False)    isAuthor=db.BooleanProperty(default=True)    #rpcpwd=db.StringProperty()    def __unicode__(self):        #if self.dispname:            return self.dispname        #else:        #    return self.user.nickname()    def __str__(self):        return self.__unicode__().encode('utf-8')COMMENT_NORMAL=0COMMENT_TRACKBACK=1COMMENT_PINGBACK=2#class Comment(DBModel):class Comment(BaseModel):    entry = db.ReferenceProperty(Entry)    date = db.DateTimeProperty(auto_now_add=True)    content = db.TextProperty(required=True)    author=db.StringProperty()    email=db.EmailProperty()    weburl=db.URLProperty()    status=db.IntegerProperty(default=0)    reply_notify_mail=db.BooleanProperty(default=False)    ip=db.StringProperty()    ctype=db.IntegerProperty(default=COMMENT_NORMAL)    no=db.IntegerProperty(default=0)    comment_order=db.IntegerProperty(default=1)    @property    def mpindex(self):        count=self.entry.commentcount        no=self.no        if self.blog.comments_order:            no=count-no+1        index=no / self.blog.comments_per_page        if no % self.blog.comments_per_page or no==0:            index+=1        return index    @property    def shortcontent(self,len=20):        scontent=self.content        scontent=re.sub(r'<br\s*/>',' ',scontent)        scontent=re.sub(r'<[^>]+>','',scontent)        scontent=re.sub(r'(@[\S]+)-\d{2,7}',r'\1:',scontent)        return scontent[:len].replace('<','&lt;').replace('>','&gt;')    def gravatar_url(self):        # Set your variables here        if self.blog.avatar_style==0:            default = self.blog.baseurl+'/static/images/homsar.jpeg'        else:            default='identicon'        if not self.email:            return default        size = 50        try:            # construct the url            imgurl = "http://www.gravatar.com/avatar/"            imgurl +=hashlib.md5(self.email.lower()).hexdigest()+"?"+ urllib.urlencode({                'd':default, 's':str(size),'r':'G'})            return imgurl        except:            return default    def save(self):        self.put()        self.comment_order=self.entry.commentcount        self.entry.commentcount+=1        if (self.ctype == COMMENT_TRACKBACK) or (self.ctype == COMMENT_PINGBACK):            self.entry.trackbackcount+=1        self.entry.put()        memcache.delete("/"+self.entry.link)        return True    def delit(self):        self.entry.commentcount-=1        if self.entry.commentcount<0:            self.entry.commentcount = 0        if (self.ctype == COMMENT_TRACKBACK) or (self.ctype == COMMENT_PINGBACK):            self.entry.trackbackcount-=1        if self.entry.trackbackcount<0:            self.entry.trackbackcount = 0        self.entry.put()        self.delete()    def put(self):        self.blog.tigger_action("pre_comment",self)        DBModel.put(self)        self.blog.tigger_action("save_comment",self)    def delete(self):        DBModel.delete(self)        self.blog.tigger_action("delete_comment",self)    @property    def children(self):        key=self.key()        comments=Comment.all().ancestor(self)        return [c for c in comments if c.parent_key()==key]    def store(self, **kwargs):        rpc = datastore.GetRpcFromKwargs(kwargs)        self._populate_internal_entity()        return datastore.Put(self._entity, rpc=rpc)class Media(DBModel):    name =db.StringProperty()    mtype=db.StringProperty()    bits=db.BlobProperty()    date=db.DateTimeProperty(auto_now_add=True)    download=db.IntegerProperty(default=0)    @property    def size(self):        return len(self.bits)class OptionSet(DBModel):    name=db.StringProperty()    value=db.TextProperty()    #blobValue=db.BlobProperty()    #isBlob=db.BooleanProperty()    @classmethod    def getValue(cls,name,default=None):        try:            opt=OptionSet.get_by_key_name(name)            return pickle.loads(str(opt.value))        except:            return default    @classmethod    def setValue(cls,name,value):        opt=OptionSet.get_or_insert(name)        opt.name=name        opt.value=pickle.dumps(value)        opt.put()    @classmethod    def remove(cls,name):        opt= OptionSet.get_by_key_name(name)        if opt:            opt.delete()NOTIFICATION_SITES = [  ('http', 'www.google.com', 'webmasters/sitemaps/ping', {}, '', 'sitemap')  ]def Sitemap_NotifySearch():    """ Send notification of the new Sitemap(s) to the search engines. """    url=self.blog.baseurl+"/sitemap"    # Cycle through notifications    # To understand this, see the comment near the NOTIFICATION_SITES comment    for ping in NOTIFICATION_SITES:      query_map             = ping[3]      query_attr            = ping[5]      query_map[query_attr] = url      query = urllib.urlencode(query_map)      notify = urlparse.urlunsplit((ping[0], ping[1], ping[2], query, ping[4]))      # Send the notification      logging.info('Notifying search engines. %s'%ping[1])      logging.info('url: %s'%notify)      try:          result = urlfetch.fetch(notify)          if result.status_code == 200:              logging.info('Notify Result: %s' % result.content)          if result.status_code == 404:              logging.info('HTTP error 404: Not Found')              logging.warning('Cannot contact: %s' % ping[1])      except :          logging.error('Cannot contact: %s' % ping[1])